// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`parseRuleFile - .gptlint/always-handle-promises.md 1`] = `
{
  "cacheable": true,
  "description": "Promises (and \`async\` functions which implicitly create Promises) must always be handled at some level of the program, either via:

- using \`await\` to wait for the Promise to resolve successfully
- using \`.then\` or \`.catch\` to handle Promise resolution
- returning a Promise to a calling function which itself has to handle the Promise

Creating a Promise or calling an \`async\` function and NOT awaiting or propagating the resulting Promise using one of these approaches is a code smell and violates this rule.

**Important**: This rule should only apply to function calls which you are 100% sure return a \`Promise\`. If you do not know for sure that a function returns a \`Promise\`, then disregard it.
",
  "fixable": false,
  "languages": [
    "javascript",
    "typescript",
  ],
  "level": "error",
  "metadata": {},
  "name": "always-handle-promises",
  "negativeExamples": [
    {
      "code": "async function saveFile() {
  // ...
}

// This is bad because we're not handling the Promise returned by \`saveFile\`
saveFile()",
      "language": "js",
    },
  ],
  "positiveExamples": [
    {
      "code": "async function saveFile() {
  // ...
}

// This is fine because we explicitly \`await\` the Promise returned by \`saveFile\`
await saveFile()",
      "language": "js",
    },
    {
      "code": "async function saveFile() {
  // ...
}

// This is fine because the Promise returned from \`saveFile\` is propagated to \`main\`'s caller
async function main() {
  return saveFile()
}",
      "language": "js",
    },
    {
      "code": "async function saveFile() {
  // ...
}

// This is fine because we explicitly \`await\` the promise results
await Promise.all([saveFile(), saveFile()])",
      "language": "js",
    },
  ],
  "scope": "file",
  "source": ".gptlint/always-handle-promises.md",
  "tags": [
    "best practices",
  ],
  "title": "Always handle Promises",
}
`;

exports[`parseRuleFile - .gptlint/avoid-type-info-in-docs.md 1`] = `
{
  "cacheable": true,
  "description": "Avoid repeating type information in comments and variable names. In the best case it is duplicative of type declarations, and in the worst it will lead to conflicting information.

Consider including units in variable names if they aren’t clear from the type (e.g., timeMs or temperatureC).

Here is an example of incorrect code:

\`\`\`ts
/**
 * Returns a string with the foreground color.
 * Takes zero or one arguments. With no arguments, returns the standard
 * foreground color. With one argument, returns the foreground color for a
 * particular page.
 */
function getForegroundColor(page?: string) {
  return page === 'login' ? { r: 127, g: 127, b: 127 } : { r: 0, g: 0, b: 0 }
}
\`\`\`

This is a VIOLATION because the comment describes the types of the function parameters and return type which duplicates the more precise TS definition. Even worse, this example is a VIOLATION because the code and the comment contradict each other.

Let’s assume that the code represents the desired behavior. There are a few issues with this comment:

- It says that the function returns the color as a string when it actually returns an \`{r, g, b}\` object.
- It explains that the function takes zero or one arguments, which is already clear from the type signature.
- It’s needlessly wordy: the comment is longer than the function declaration and implementation.

Since your type annotations are checked by the TypeScript compiler, they’ll never get out of sync with the implementation.

A better comment might look like this:

\`\`\`ts
/** Get the foreground color for the application or a specific page. */
function getForegroundColor(page?: string): Color {
  // ...
}
\`\`\`

Comments about a lack of mutation are also suspect. Don’t just say that you don’t modify a parameter:

\`\`\`ts
/** Does not modify nums */
function sort(nums: number[]) {
  /* ... */
}
\`\`\`

Instead, declare the parameter as \`readonly\` and let TypeScript enforce the contract:

\`\`\`ts
function sort(nums: readonly number[]) {
  /* ... */
}
\`\`\`

## Caveats

Note that you do NOT have to include JSDoc comments for a function, and you do NOT have to include \`@param\` or \`@returns\` JSDoc properties. These are purely optional, but if they are included, they should not discuss the types of function parameters because TypeScript does a better job of capturing this info in the function definition itself.

If a comment is providing useful context or clarifying what a parameter is used for, then it should be ignored. This rule is only aimed at comments which duplicate type info or comments which imply immutability.
",
  "exclude": [
    "**/*\\.test\\.{js,ts,jsx,tsx,cjs,mjs}",
  ],
  "fixable": false,
  "gritql": "comment",
  "gritqlNumLinesContext": 3,
  "languages": [
    "typescript",
  ],
  "level": "error",
  "metadata": {},
  "name": "avoid-type-info-in-docs",
  "negativeExamples": [],
  "positiveExamples": [
    {
      "code": "/**
 * Upserts a user into the database.
 */
export async function upsertUser(
  user: User | NewUserData,
  ctx?: Context
): Promise<User> {
  // ...
}",
      "language": "ts",
    },
    {
      "code": "/**
 * Upserts a user into the database.
 *
 * @param user - The user to upsert.
 * @param ctx - Optional context for the database operation.
 *
 * @returns The upserted user.
 */
export async function upsertUser(
  user: User | NewUserData,
  ctx?: Context
): Promise<User> {
  // ...
}",
      "language": "ts",
    },
    {
      "code": "/**
 * Parses a string using a zod schema.
 *
 * @param output - string to parse
 * @param outputSchema - zod schema
 *
 * @returns parsed output
 */
export function parseStructuredOutput<T>(
  output: string,
  outputSchema: ZodType<T>
): T {
  // ...
}

// This example is fine because the type info in the JSDoc \`@param\` comments is relevant and simple.",
      "language": "ts",
    },
  ],
  "resources": [
    "https://effectivetypescript.com",
  ],
  "scope": "file",
  "source": ".gptlint/avoid-type-info-in-docs.md",
  "tags": [
    "best practices",
  ],
  "title": "Don’t repeat type information in documentation",
}
`;

exports[`parseRuleFile - .gptlint/consistent-identifier-casing.md 1`] = `
{
  "cacheable": true,
  "description": "Identifiers of the same type should try to use consistent casing.

Variable names should use camelCase.
Global const variable names should either use camelCase, PascalCase, or CONSTANT\\_CASE.
Type names should use PascalCase.
Class names should use PascalCase.
Function names should use camelCase.

Examples of camelCase identifiers include: foo, fooBar, h1RuleNodes, cwd, apiBaseUrl, apiBaseURL, validRuleTableKeysL, and \\_getKey.

## Caveats

Third-party APIs may use inconsistent casing, which is an exception to this rule.

Keys in JSON objects, JS objects, and TypeScript objects may use inconsistent casing, so they are exceptions to this rule.

Ignore identifiers which mix PascalCase with camelCase.

Ignore the casing of common acronyms like API, IP, HTTP, and LLM.

Ignore the casing of identifiers which start with acronyms like \`LLMOptionsSchema\`.

Ignore parameter names used in inline functions.

Ignore string literals and module names for this rule.

Class member variables and functions may include \`_\` prefixes.
",
  "eslint": [
    "@typescript-eslint/naming-convention",
    "camelcase",
  ],
  "fixable": false,
  "gritql": "or {
  type_identifier() as $id where {
    and {
      $id <: within or {
        type_alias_declaration($name),
        interface_declaration($name),
        class_declaration($name)
      },
      $id <: $name
    }
  },

  identifier() as $id where {
    or {
      and {
        $id <: within or {
          variable_declarator($name),
          function_declaration($name),
          class_declaration($name),
          method_signature($name),
          method_definition($name),
          required_parameter($name),
          optional_parameter($name)
        },
        $id <: $name
      },

      or {
        and {
          $id <: within \`function $func($props): $ret {$body}\`,
          $id <: not or { within $body, within $func }
        },
        and {
          $id <: within \`function $func($props) {$body}\`,
          $id <: not or { within $body, within $func }
        },
        and {
          $id <: within \`($props) => $body\`,
          $id <: not or { within $body }
        }
      }
    }
  },

  property_identifier() as $id where {
    and {
      $id <: within or { method_signature($name), method_definition($name) },
      $id <: $name
    }
  }
}",
  "languages": [
    "javascript",
    "typescript",
  ],
  "level": "error",
  "metadata": {},
  "name": "consistent-identifier-casing",
  "negativeExamples": [
    {
      "code": "// These are bad because variable identifiers should use consistent casing.
const fooBar = true
const default_timeout = 5000

// These are bad because function identifiers should use consistent casing.
function helloWorld() {}
function hello_twitter() {}",
      "language": "ts",
    },
  ],
  "positiveExamples": [
    {
      "code": "const fooBar = true
const defaultTimeout = 5000

function helloWorld() {}
function helloTwitter() {}",
      "language": "ts",
    },
    {
      "code": "import foo from 'foo'

// This is fine because \`foo\` is a third-party API which this rule should ignore.
foo({ camelCase: true, snake_case: true, SNAKE_CASE: true })",
      "language": "ts",
    },
    {
      "code": "// These are all fine as common exceptions to this rule
export const HTTPConfig = {}
const LLMOptions = {}
const validKeysL = new Set()
const loadingP = new Promise()
const cwd = process.cwd",
      "language": "ts",
    },
    {
      "code": "// This is fine because \`i\` is a parameter of an inline function and \`res\` is a common exception.
const res = [1, 2, 3].filter((i) => i >= 0)",
      "language": "ts",
    },
  ],
  "scope": "file",
  "source": ".gptlint/consistent-identifier-casing.md",
  "tags": [
    "best practices",
  ],
  "title": "Be consistent with identifier casing",
}
`;

exports[`parseRuleFile - .gptlint/custom/prefer-fetch-over-axios.md 1`] = `
{
  "cacheable": true,
  "description": "The NPM package \`axios\` should be avoided in favor of native \`fetch\`. Now that native \`fetch\` has widespread support, \`axios\` is effectively deprecated and is generally a code smell when encountered.

Convenience wrappers around \`fetch\` such as \`ky\` and \`ofetch\` are encouraged.

Code which doesn't use the \`axios\` module should be ignored.
",
  "eslint": [
    "no-restricted-imports",
  ],
  "fixable": false,
  "languages": [
    "javascript",
    "typescript",
  ],
  "level": "error",
  "metadata": {},
  "name": "prefer-fetch-over-axios",
  "negativeExamples": [],
  "positiveExamples": [],
  "scope": "file",
  "source": ".gptlint/custom/prefer-fetch-over-axios.md",
  "tags": [
    "best practices",
  ],
  "title": "Prefer fetch over axios",
}
`;

exports[`parseRuleFile - .gptlint/liberal-accept-strict-produce.md 1`] = `
{
  "cacheable": true,
  "description": "Postel's Law, also known as the Robustness Principle, is a design guideline that promotes interoperability, flexibility, and reliability. It states:

1. **Be liberal in what you accept**: When receiving input or interacting with other systems, be tolerant and accept a wide range of possible inputs. Handle minor variations, deviations, or even slightly malformed input gracefully, without rejecting it outright.

2. **Be strict in what you produce**: When sending output or data to other systems, adhere to the specified format or protocol strictly. Generate well-formed, valid output that conforms to the expected standards or specifications.

The intent behind Postel's Law is to build robust and resilient systems that can handle imperfect or unexpected input from other components while ensuring that the output they generate is precise and reliable. By accepting a broader range of inputs, a system can be more compatible and interoperable with other systems. By producing strict and well-defined output, a system can provide predictable and consistent data to its consumers.

When applied to code, Postel's Law suggests that functions, methods, or interfaces should:

- Accept a wide range of valid inputs, including edge cases or minor variations.
- Be tolerant of input that may not perfectly match the expected format or type.
- Produce output that strictly adheres to the specified format, type, or contract.
- Generate predictable and well-formed output, even in the face of unexpected or erroneous input.

Violating Postel's Law can lead to brittle, inflexible code that breaks easily when interacting with other systems or when receiving input that doesn't exactly match expectations. It can also lead to producing output that is inconsistent, malformed, or ambiguous, making it difficult for other parts of the system to consume or rely on.
",
  "exclude": [
    "**/*\\.test\\.{js,ts,jsx,tsx,cjs,mjs}",
  ],
  "fixable": false,
  "gritql": "function_declaration",
  "gritqlNumLinesContext": 3,
  "languages": [
    "typescript",
  ],
  "level": "error",
  "metadata": {},
  "name": "liberal-accept-strict-produce",
  "negativeExamples": [
    {
      "code": "// Throws an error if the array is empty, doesn't handle strings or other types
function calculateAverage(numbers: number[]): number {
  if (numbers.length === 0) {
    throw new Error('Empty array provided')
  }
  const sum = numbers.reduce((acc, num) => acc + num, 0)
  return sum / numbers.length
}

// Only accepts a Date object, doesn't handle string or number input
function formatDate(date: Date): string {
  return date.toISOString()
}

// Expects a user object with a required name property, doesn't handle null or missing name
function getUserName(user: { name: string }): string {
  return user.name
}",
      "language": "ts",
    },
  ],
  "positiveExamples": [
    {
      "code": "// Accepts numbers or strings, filters out valid numbers, handles empty array gracefully
function calculateAverage(numbers: (number | string)[]): number {
  const validNumbers = numbers.filter((num) => typeof num === 'number')
  if (validNumbers.length === 0) {
    return 0
  }
  const sum = validNumbers.reduce((acc, num) => acc + Number(num), 0)
  return sum / validNumbers.length
}

// Accepts Date, string, or number input, attempts to parse the input, returns 'Invalid Date' for invalid input
function formatDate(date: Date | string | number): string {
  const parsedDate = new Date(date)
  if (isNaN(parsedDate.getTime())) {
    return 'Invalid Date'
  }
  return parsedDate.toISOString()
}

// Accepts a user object with an optional name property or null, returns 'Anonymous' as a default value
function getUserName(user: { name?: string } | null): string {
  if (user && user.name) {
    return user.name
  }
  return 'Anonymous'
}",
      "language": "ts",
    },
  ],
  "resources": [
    "https://effectivetypescript.com",
  ],
  "scope": "file",
  "source": ".gptlint/liberal-accept-strict-produce.md",
  "tags": [
    "best practices",
  ],
  "title": "Postel's Law: Be Liberal in What You Accept, Strict in What You Produce",
}
`;

exports[`parseRuleFile - .gptlint/no-hardcoded-secrets.md 1`] = `
{
  "cacheable": true,
  "description": "Sensitive secrets should never be hardcoded in git because they represent a serious security risk.

Common use cases for secrets include:

- private API keys and tokens
- authentication and authorization
- third-party service config
- private encryption keys
- cryptographic secrets for signing requests

The most common solution is to only access secrets from environment variables so they aren't committed as code.
",
  "fixable": false,
  "gritql": "or { string(), template_string() }",
  "gritqlNumLinesContext": 3,
  "languages": [
    "all",
  ],
  "level": "error",
  "metadata": {},
  "name": "no-hardcoded-secrets",
  "negativeExamples": [
    {
      "code": "const apiKey = 'sk-J6tsSvil9M7zF76PkyU...'",
      "language": "js",
    },
    {
      "code": "import OpenAI from 'openai'

const openai = new OpenAI({
  apiKey: 'sk-J6tsSvil9M7zF76PkyU...'
})",
      "language": "js",
    },
  ],
  "positiveExamples": [
    {
      "code": "const apiKey = process.env.OPENAI_API_KEY",
      "language": "js",
    },
    {
      "code": "const apiKey = process.env['OPENAI_API_KEY']",
      "language": "js",
    },
    {
      "code": "const apiKey = getEnv('OPENAI_API_KEY')",
      "language": "js",
    },
    {
      "code": "import OpenAI from 'openai'

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
})",
      "language": "ts",
    },
  ],
  "scope": "file",
  "source": ".gptlint/no-hardcoded-secrets.md",
  "tags": [
    "security",
  ],
  "title": "No hardcoded secrets",
}
`;

exports[`parseRuleFile - .gptlint/prefer-array-at-negative-indexing.md 1`] = `
{
  "cacheable": true,
  "description": "When accessing items in an array from the end, like the last item, prefer using \`Array.at\` with a negative index because it is less error-prone. Note that using \`Array.at\` with a positive index is equivalent to indexing into the array normally, and if \`Array.at\` references a non-existing index, it will return \`undefined\`.
",
  "eslint": [
    "@unicorn/prefer-negative-index",
  ],
  "fixable": false,
  "gritql": "subscript_expression",
  "gritqlNumLinesContext": 3,
  "languages": [
    "javascript",
    "typescript",
  ],
  "level": "error",
  "metadata": {},
  "name": "prefer-array-at-negative-indexing",
  "negativeExamples": [
    {
      "code": "const items = [1, 2, 3, 4, 5, 6, 7]
const lastItem = items[items.length - 1]",
      "language": "ts",
    },
  ],
  "positiveExamples": [
    {
      "code": "const items = [1, 2, 3, 4, 5, 6, 7]
const lastItem = items.at(-1)",
      "language": "ts",
    },
    {
      "code": "const items = [1, 2, 3, 4, 5, 6, 7]

// This example is fine because it uses a normal, positive index
const firstItem = items[0]",
      "language": "ts",
    },
    {
      "code": "const items = [1, 2, 3, 4, 5, 6, 7]
const index = example()

// This example is fine because it uses a variable index
const item = items[index]",
      "language": "ts",
    },
  ],
  "resources": [
    "https://twitter.com/housecor/status/1768622518179369036",
  ],
  "scope": "file",
  "source": ".gptlint/prefer-array-at-negative-indexing.md",
  "tags": [
    "best practices",
  ],
  "title": "Prefer using Array.at when indexing from the end of an array",
}
`;

exports[`parseRuleFile - .gptlint/prefer-loose-array-bounds-checks-in-loops.md 1`] = `
{
  "cacheable": true,
  "description": "Array bounds checks within loops should verify if a variable is \`>=\` or \`<=\` the array length instead of exactly equal to the array length. Performing strict bound checks on arrays in loops is brittle and a common cause of subtle bugs.

\`\`\`js
function handleTasks() {
  const tasks = [
    // ...
  ]
  let currentTaskIndex = 0

  do {
    const currentTask = tasks[currentTaskIndex]

    // process task
    // ...

    currentTaskIndex++
  } while (currentTaskIndex !== tasks.length)
}
\`\`\`

This example has two bugs:

- if \`tasks\` is empty, the first iteration of the while loop will throw an error
- the \`while\` loop guard is very brittle which is a code smell. if \`currentTaskIndex\` somehow gets changed in an unexpected way with future code changes, then the \`while\` loop guard could end up going past the end of the tasks array!

An improved version of this code which fixes these buse looks like:

\`\`\`js
function handleTasks() {
  const tasks = [
    // ...
  ]
  let currentTaskIndex = 0

  while (currentTaskIndex < tasks.length) {
    const currentTask = tasks[currentTaskIndex]

    // process task
    // ...

    currentTaskIndex++
  }
}
\`\`\`
",
  "exclude": [
    "**/*.test\\.{js,ts,jsx,tsx,cjs,mjs}",
  ],
  "fixable": false,
  "gritql": "or {
  any_equals(a = \`$foo.length\`, $b),
  any_not_equals(a = \`$foo.length\`, $b)
} as $op where {
  $op <: within or {
    do_statement(),
    while_statement(),
    for_statement()
  }
}",
  "languages": [
    "javascript",
    "typescript",
  ],
  "level": "error",
  "metadata": {},
  "name": "prefer-loose-array-bounds-checks-in-loops",
  "negativeExamples": [
    {
      "code": "for (let i = 0; i !== arr.length; i++) {
  // this is bad because it should use \`i < arr.length\` to be safer
}",
      "language": "js",
    },
    {
      "code": "for (let i = arr.length; i !== -1; i--) {
  // this is bad because it should use \`i >= 0\` or \`i > -1\` to be safer
}",
      "language": "ts",
    },
    {
      "code": "while (i !== tasks.length) {
  // this is bad because it should use \`i < tasks.length\` to be safer
  ++i
}",
      "language": "js",
    },
    {
      "code": "const length = arr.length
let i = 0
while (i !== length) {
  // this is bad because the while loop should use \`i < length\` to be safer
  ++i
}",
      "language": "ts",
    },
  ],
  "positiveExamples": [
    {
      "code": "for (let i = 0; i < arr.length; i++) {}",
      "language": "js",
    },
    {
      "code": "for (let i = arr.length; i >= 0; i--) {}",
      "language": "ts",
    },
    {
      "code": "while (i < tasks.length) {
  ++i
}",
      "language": "js",
    },
  ],
  "scope": "file",
  "source": ".gptlint/prefer-loose-array-bounds-checks-in-loops.md",
  "tags": [
    "best practices",
  ],
  "title": "Prefer loose array bounds checks in loops",
}
`;

exports[`parseRuleFile - .gptlint/prefer-types-always-valid-states.md 1`] = `
{
  "cacheable": true,
  "description": "A key to effective type design is crafting types that can only represent a valid state. This rule walks through a few examples of how this can go wrong and shows you how to fix them.

As an example, suppose you’re building a web application that lets you select a page, loads the con‐ tent of that page, and then displays it. You might write the state like this:

\`\`\`ts
interface State {
  pageText: string
  isLoading: boolean
  error?: string
}
\`\`\`

When you write your code to render the page, you need to consider all of these fields:

\`\`\`ts
function renderPage(state: State) {
  if (state.error) {
    return \`Error! Unable to load \${currentPage}: \${state.error}\`
  } else if (state.isLoading) {
    return \`Loading \${currentPage}...\`
  }
  return \`<h1>\${currentPage}</h1>\\n\${state.pageText}\`
}
\`\`\`

Is this right, though? What if \`isLoading\` and \`error\` are both set? What would that mean? Is it better to display the loading message or the error message? It’s hard to say! There’s not enough information available.

Or what if you’re writing a \`changePage\` function? Here’s an attempt:

\`\`\`ts
async function changePage(state: State, newPage: string) {
  state.isLoading = true
  try {
    const response = await fetch(getUrlForPage(newPage))
    if (!response.ok) {
      throw new Error(\`Unable to load \${newPage}: \${response.statusText}\`)
    }
    const text = await response.text()
    state.isLoading = false
    state.pageText = text
  } catch (e) {
    state.error = '' + e
  }
}
\`\`\`

There are many problems with this! Here are a few:

- We forgot to set \`state.isLoading\` to \`false\` in the error case.
- We didn’t clear out \`state.error\`, so if the previous request failed, then you’ll keep seeing that error message instead of a loading message.
- If the user changes pages again while the page is loading, who knows what will happen. They might see a new page and then an error, or the first page and not the second depending on the order in which the responses come back.

The problem is that the state includes both too little information (which request failed? which is loading?) and too much: the \`State\` type allows both \`isLoading\` and \`error\` to be set, **even though this represents an invalid state**. This makes both \`render()\` and \`changePage()\` impossible to implement well.

Here’s a better way to represent the application state:

\`\`\`ts
interface RequestPending {
  state: 'pending'
}
interface RequestError {
  state: 'error'
  error: string
}
interface RequestSuccess {
  state: 'ok'
  pageText: string
}
type RequestState = RequestPending | RequestError | RequestSuccess
interface State {
  currentPage: string
  requests: { [page: string]: RequestState }
}
\`\`\`

This uses a tagged union (also known as a “discriminated union”) to explicitly model the different states that a network request can be in. This version of the state is three to four times longer, but it has the enormous advantage of not admitting invalid states. The current page is modeled explicitly, as is the state of every request that you issue. As a result, the \`renderPage\` and \`changePage\` functions are easy to implement:

\`\`\`ts
function renderPage(state: State) {
  const { currentPage } = state
  const requestState = state.requests[currentPage]

  switch (requestState.state) {
    case 'pending':
      return \`Loading \${currentPage}...\`
    case 'error':
      return \`Error! Unable to load \${currentPage}: \${requestState.error}\`
    case 'ok':
      return \`<h1>\${currentPage}</h1>\\n\${requestState.pageText}\`
  }
}

async function changePage(state: State, newPage: string) {
  state.requests[newPage] = { state: 'pending' }
  state.currentPage = newPage

  try {
    const response = await fetch(getUrlForPage(newPage))
    if (!response.ok) {
      throw new Error(\`Unable to load \${newPage}: \${response.statusText}\`)
    }
    const pageText = await response.text()
    state.requests[newPage] = { state: 'ok', pageText }
  } catch (e) {
    state.requests[newPage] = { state: 'error', error: '' + e }
  }
}
\`\`\`

The ambiguity from the first implementation is entirely gone: it’s clear what the cur‐ rent page is, and every request is in exactly one state. If the user changes the page after a request has been issued, that’s no problem either. The old request still com‐ pletes, but it doesn’t affect the UI.

---

Oftentimes this rule pairs with the ideal of having as little mutable state as possible and preferring to derive state based on a small source of truth which is always valid.

For example, let's say you have a product resource:

\`\`\`ts
class Product {
  isInStock: boolean
  quantityAvailable: number
}
\`\`\`

\`Product\` has a few problems here:

- \`isInStock\` can be false with \`quantityAvailable > 0\` which doesn't make any sense
- \`isInStock\` can be true with \`quantityAvailable === 0\` which doesn't make any sense

The problem comes from \`Product.isInStock\` and \`Product.quantityAvailable\` both representing different aspects of the same underling data: in this case, how much of a product is currently available.

A better solution would be to only store the minimal state necessary to model the \`Product\`'s valid states, and then derive any additional fields based on the model's minimal, valid state:

\`\`\`ts
class Product {
  quantityAvailable: number

  get isInStock() {
    // Derived based on \`quantityAvailable\` which guarantees that the product's
    // state is always valid.
    return this.quantityAvailable > 0
  }
}
\`\`\`

## Caveats

When working with external APIs and data sources, it's not always possible to work with types which only represent valid state. So this rule should ignore any data coming from external dependencies and focus instead on types used internally within this project.

## Key Takeaways

Types that represent both valid and invalid states are likely to lead to confusing and error-prone code.

Prefer types that only represent valid states. Even if they are longer or harder to express, they will save you time and pain in the end.

If a field is useful, but adding it to a type could result the type representing invalid states, then consider whether that field can be derived from a minimal set of state that is always valid.
",
  "exclude": [
    "**/*\\.test\\.{js,ts,jsx,tsx,cjs,mjs}",
    "**/*\\.{js,cjs,mjs,json}",
  ],
  "fixable": false,
  "gritql": "or {
  type_alias_declaration(),
  interface_declaration()
}",
  "gritqlNumLinesContext": 3,
  "languages": [
    "typescript",
  ],
  "level": "error",
  "metadata": {},
  "name": "prefer-types-always-valid-states",
  "negativeExamples": [],
  "positiveExamples": [],
  "resources": [
    "https://effectivetypescript.com",
  ],
  "scope": "file",
  "source": ".gptlint/prefer-types-always-valid-states.md",
  "tags": [
    "best practices",
  ],
  "title": "Prefer types that always represent valid states",
}
`;

exports[`parseRuleFile - .gptlint/react-avoid-class-components.md 1`] = `
{
  "cacheable": true,
  "description": "React class components are deprecated. Use React functions and hooks instead.

Note that uses \`classes\` is fine for non-react components.
",
  "eslint": [
    "eslint-plugin-react-prefer-function-component",
  ],
  "fixable": false,
  "gritql": "react_class_component",
  "include": [
    "**/*.{jsx,tsx}",
  ],
  "languages": [
    "javascript",
    "typescript",
  ],
  "level": "error",
  "metadata": {},
  "name": "react-avoid-class-components",
  "negativeExamples": [
    {
      "code": "import { Component } from 'react'

export class Label extends Component {
  render() {
    return <div>Hello</div>
  }
}",
      "language": "tsx",
    },
    {
      "code": "import react from 'react'

export class Label extends react.Component {
  render() {
    return <div />
  }
}",
      "language": "tsx",
    },
  ],
  "positiveExamples": [
    {
      "code": "export function Button() {
  return <div>Hello</div>
}",
      "language": "tsx",
    },
    {
      "code": "import EventEmitter from 'eventemitter3'

// This is fine because it is a normal class and not a React component.
class Foo extends EventEmitter {
  constructor() {}
}",
      "language": "ts",
    },
  ],
  "scope": "file",
  "source": ".gptlint/react-avoid-class-components.md",
  "tags": [
    "react",
  ],
  "title": "Don't use React class components",
}
`;

exports[`parseRuleFile - .gptlint/semantic-variable-names.md 1`] = `
{
  "cacheable": true,
  "description": "Variable names should be descriptive and capture the semantics of the value they represent. This makes it easier to read and understand code. It also makes it clearer when variables are being misused.

## Caveats

An exception to this rule is that it is acceptable to use simple variable names like \`i\` in \`for\` loops.

An exception to this rule is that math-heavy code may use simple variable names within the scope of a mathematically dense function.

Common acronyms like \`api\`, \`ast\`, and \`llm\` are fine even though they aren't as descriptive.

\`res\`, \`result\`, and \`data\` are common exceptions that are okay to ignore.

Variables names which mirror the corresponding type name are okay to ignore.

Keys in objects and JS/TS strings are not variable names, so they should be ignored.

If a value isn't a variable name, then it should be ignored.

This rule should be ignored in test files.

The names of file imports from third-party APIs and modules should be ignored because we have no control over them.

If you are unsure whether or not a variable name is descriptive enough, err on the side of ignoring it or setting \`confidence\` to \`low\`.
",
  "exclude": [
    "**/*\\.test\\.{js,ts,jsx,tsx,cjs,mjs}",
  ],
  "fixable": false,
  "gritql": "identifier() as $id where {
  or {
    and {
      $id <: within or {
        variable_declarator($name),
        required_parameter($name),
        optional_parameter($name)
      },
      $id <: $name
    },

    or {
      and {
        $id <: within \`function $func($props): $ret {$body}\`,
        $id <: not or { within $body, within $func }
      },
      and {
        $id <: within \`function $func($props) {$body}\`,
        $id <: not or { within $body, within $func }
      },
      and {
        $id <: within \`($props) => $body\`,
        $id <: not within $body
      }
    }
  }
}",
  "gritqlNumLinesContext": 2,
  "languages": [
    "javascript",
    "typescript",
  ],
  "level": "error",
  "metadata": {},
  "name": "semantic-variable-names",
  "negativeExamples": [
    {
      "code": "// Bad because "a" is not a descriptive variable name
const a = 5

// Bad because "b" is not a descriptive variable name
const b = false",
      "language": "ts",
    },
    {
      "code": "// Bad because "obj" is not a descriptive variable name
const obj = { id: 5, name: 'Bob' }",
      "language": "js",
    },
  ],
  "positiveExamples": [
    {
      "code": "// Good because "numTokens" is descriptive
const numTokens = 5

// Good because "isFinished" is descriptive
const isFinished = true

// Good because "ast" is an acronym
const ast = parseAST()

// Good because "fileTypeToParserMap" is very descriptive
const fileTypeToParserMap: Record<string, string> = {}",
      "language": "ts",
    },
    {
      "code": "// "i" is okay here because it is a simple for loop
for (let i = 0; i < 10; i++) {}",
      "language": "ts",
    },
    {
      "code": "// "x", "y", and "r" are all okay here because they represent real, mathematical
// concepts, and concise variable names are often preferred in math-heavy code.
function normalDist(mu = 0, sigma = 1) {
  let x: number, y: number, r: number

  do {
    x = Math.random() * 2 - 1
    y = Math.random() * 2 - 1
    r = x * x + y * y
  } while (!r || r > 1)

  return mu + sigma * y * Math.sqrt((-2 * Math.log(r)) / r)
}",
      "language": "ts",
    },
    {
      "code": "// These are fine because the simple variable names match the corresponding type names.
const rule: Rule = {}
const data: Data = {}",
      "language": "ts",
    },
    {
      "code": "// This is fine because \`z\` is an external dependency that we have no control over.
import { z } from 'zod'",
      "language": "ts",
    },
  ],
  "scope": "file",
  "source": ".gptlint/semantic-variable-names.md",
  "tags": [
    "best practices",
  ],
  "title": "Use semantic variable names",
}
`;

exports[`parseRuleFile - .gptlint/soc2-no-leak-user-data.md 1`] = `
{
  "cacheable": true,
  "description": "Don't log potentially sensitive customer data or we'll lose our SOC2 certification.

Non-identifying user data such as internal IDs or other internal models related to a user are fine to log and expose.
",
  "fixable": false,
  "gritql": "or {
  \`console.$method($args)\`,
  \`logger.$method($args)\`,
  \`log.$method($args)\`,
  \`throw new $Error($msg)\`
}",
  "gritqlNumLinesContext": 2,
  "languages": [
    "javascript",
    "typescript",
  ],
  "level": "error",
  "metadata": {},
  "name": "soc2-no-leak-user-data",
  "negativeExamples": [
    {
      "code": "// Don't log potentially sensitive user data
console.log(user)",
      "language": "js",
    },
    {
      "code": "// Don't log potentially sensitive user data
log.info(user)",
      "language": "js",
    },
    {
      "code": "// Don't log sensitive user information like \`email\`
console.error('Invalid user', user.email)",
      "language": "js",
    },
    {
      "code": "// Don't log request bodies which may contain sensitive user data
log.info({ body: req.body })",
      "language": "js",
    },
    {
      "code": "// Don't expose request bodies which may contain sensitive user data
throw new Error('error', { body: req.body })",
      "language": "js",
    },
  ],
  "positiveExamples": [
    {
      "code": "// Logging non-identifying user data such as internal IDs is fine
console.log(user.id)",
      "language": "js",
    },
    {
      "code": "// Logging non-identifying user data such as internal IDs is fine
logger.warn(\`Invalid user: \${user.id}\`)",
      "language": "js",
    },
    {
      "code": "// Exposing non-identifying user data such as internal IDs is fine
throw new Error(\`User error \${user.id}\`)",
      "language": "ts",
    },
    {
      "code": "// Logging internal resources related to a user is okay
console.log(user.posts)",
      "language": "js",
    },
  ],
  "scope": "file",
  "source": ".gptlint/soc2-no-leak-user-data.md",
  "tags": [
    "security",
  ],
  "title": "SOC2 Don't leak user data",
}
`;

exports[`parseRuleFile - .gptlint/use-correct-english.md 1`] = `
{
  "cacheable": true,
  "description": "All comments and documentation should use correct English spelling and grammar. Obvious spelling errors should be repoted as violations.

This rule applies to code comments, JSDoc comments, and markdown documentation.

## Caveats

This rule does *not* apply to code identifiers (variable names, function names, type names, etc) which often use shorthand.

This rule also does not apply to \`TODO\` comments.
",
  "fixable": false,
  "gritql": "comment",
  "level": "error",
  "metadata": {},
  "name": "use-correct-english",
  "negativeExamples": [
    {
      "code": "This is a violation becuse it includs spelling errors.",
      "language": "md",
    },
    {
      "code": "This example uses broken english grammar because bad.",
      "language": "md",
    },
  ],
  "positiveExamples": [],
  "scope": "file",
  "source": ".gptlint/use-correct-english.md",
  "tags": [
    "best practices",
  ],
  "title": "Docs should use correct English spelling and grammar",
}
`;

exports[`parseRuleFile - fixtures/valid-rules/empty-examples.md 1`] = `
{
  "cacheable": true,
  "description": "This rule doesn't contain any examples which is fine because they are optional.
",
  "level": "error",
  "metadata": {},
  "name": "empty-examples",
  "negativeExamples": [],
  "positiveExamples": [],
  "scope": "file",
  "source": "fixtures/valid-rules/empty-examples.md",
  "title": "Example",
}
`;

exports[`parseRuleFile - fixtures/valid-rules/force-list-pagination.md 1`] = `
{
  "cacheable": true,
  "description": "Force the use of pagination for all lists in GraphQL.

## Usage Examples
",
  "fixable": true,
  "languages": [
    "javascript",
    "typescript",
  ],
  "level": "warn",
  "metadata": {},
  "name": "force-list-pagination",
  "negativeExamples": [
    {
      "code": "type Query {
  items: [ItemConnection]
  requiredItems: [ItemConnection!]
  nestedRequireItems: [ItemConnection!]!
}",
      "language": "graphql",
    },
  ],
  "positiveExamples": [
    {
      "code": "type ListPaginationInput {
  first: Int
  last: Int
  after: String
  before: String
}

type Query {
  items(pagination: ): [ItemConnection]
  requiredItems: [ItemConnection!]
  nestedRequireItems: [ItemConnection!]!
}",
      "language": "graphql",
    },
  ],
  "scope": "file",
  "source": "fixtures/valid-rules/force-list-pagination.md",
  "tags": [
    "graphql",
  ],
  "title": "Force List Pagination",
}
`;

exports[`parseRuleFile - fixtures/valid-rules/metadata-0.md 1`] = `
{
  "cacheable": true,
  "description": "This example should parse correctly.
",
  "eslint": [
    "example-eslint-rule-1",
    "example-eslint-rule-2",
  ],
  "fixable": false,
  "languages": [
    "javascript",
    "typescript",
  ],
  "level": "error",
  "metadata": {},
  "name": "metadata-0",
  "negativeExamples": [],
  "positiveExamples": [],
  "scope": "file",
  "source": "fixtures/valid-rules/metadata-0.md",
  "tags": [
    "general",
  ],
  "title": "Example",
}
`;

exports[`parseRuleFile - fixtures/valid-rules/metadata-1.md 1`] = `
{
  "cacheable": true,
  "description": "This example should parse correctly.
",
  "eslint": [
    "example-eslint-rule-1",
    "example-eslint-rule-2",
  ],
  "fixable": true,
  "languages": [
    "javascript",
    "typescript",
  ],
  "level": "off",
  "metadata": {},
  "name": "metadata-1",
  "negativeExamples": [],
  "positiveExamples": [],
  "scope": "file",
  "source": "fixtures/valid-rules/metadata-1.md",
  "tags": [
    "general",
  ],
  "title": "Example",
}
`;

exports[`parseRuleFile - fixtures/valid-rules/mutations.md 1`] = `
{
  "cacheable": true,
  "description": "Disallow empty arguments for mutation Enforcing naming conventions for mutation input names and mutation return types.

## Usage Examples

\`.eslintrc\`

\`\`\`json
{
  "rules": {
    "@ux-l_graphql-eslint/mutation-types": "error"
  }
}
\`\`\`
",
  "eslint": [
    "@ux-l_graphql-eslint/mutation-types",
  ],
  "level": "error",
  "metadata": {},
  "name": "mutations",
  "negativeExamples": [
    {
      "code": "type Mutation {
  setMessage(message: SetMessageInput, other: String): String
}
type Mutation {
  setMessage(message: String): String
}
type Mutation {
  setMessage: String
}
type Mutation {
  setMessage(input: setMessageInput): setMessageResponse
}",
      "language": "graphql",
    },
  ],
  "positiveExamples": [
    {
      "code": "type Mutation {
  setMessage(input: SetMessageInput): SetMessageResponse
}
type Mutation {
  setMessage(input: [SetMessageInput]): SetMessageResponse
}",
      "language": "graphql",
    },
  ],
  "scope": "file",
  "source": "fixtures/valid-rules/mutations.md",
  "tags": [
    "graphql",
  ],
  "title": "Mutation Inputs",
}
`;

exports[`parseRuleFile - fixtures/valid-rules/prefer-edge-node.md 1`] = `
{
  "cacheable": true,
  "description": "Prefer usage of Edges and Nodes in GraphQL Lists.

## Usage Examples
",
  "level": "error",
  "metadata": {},
  "name": "prefer-edge-node",
  "negativeExamples": [
    {
      "code": "type Item {
  id: ID
  name: String
}

type Query {
  items: [Item]
  requiredItems: [Item!]
  nestedRequireItems: [Item!]!
}",
      "language": "graphql",
    },
  ],
  "positiveExamples": [
    {
      "code": "type Item {
  id: ID
  name: String
}

type ItemEdge {
  node: Node!
  cursor: String!
}

type ItemConnection {
  edges: [ItemEdge]
  pageInfo: PageInfo!
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  resultCount: Int!
}

type Query {
  items: [ItemConnection]
  requiredItems: [ItemConnection!]
  nestedRequireItems: [ItemConnection!]!
}",
      "language": "graphql",
    },
  ],
  "scope": "file",
  "source": "fixtures/valid-rules/prefer-edge-node.md",
  "title": "Prefer Edges & Nodes",
}
`;

exports[`parseRuleFile - fixtures/valid-rules/prefer-loose-array-bounds-checks-in-loops.md 1`] = `
{
  "cacheable": true,
  "description": "Array bounds checks within loops should verify if a variable is \`>=\` or \`<=\` the array length instead of exactly equal to the array length. Performing strict bound checks on arrays in loops is brittle and a common cause of subtle bugs.

\`\`\`js
function handleTasks() {
  const tasks = [
    // ...
  ]
  let currentTaskIndex = 0

  do {
    const currentTask = tasks[currentTaskIndex]

    // process task
    // ...

    currentTaskIndex++
  } while (currentTaskIndex !== tasks.length)
}
\`\`\`

This example has two bugs:

- if \`tasks\` is empty, the first iteration of the while loop will throw an error
- the \`while\` loop guard is very brittle which is a code smell. if \`currentTaskIndex\` somehow gets changed in an unexpected way with future code changes, then the \`while\` loop guard could end up going past the end of the tasks array!

An improved version of this code which fixes these buse looks like:

\`\`\`js
function handleTasks() {
  const tasks = [
    // ...
  ]
  let currentTaskIndex = 0

  while (currentTaskIndex < tasks.length) {
    const currentTask = tasks[currentTaskIndex]

    // process task
    // ...

    currentTaskIndex++
  }
}
\`\`\`
",
  "exclude": [
    "**/*.test\\.{js,ts,jsx,tsx,cjs,mjs}",
  ],
  "fixable": false,
  "gritql": "or {
  do_statement(),
  while_statement(),
  for_statement()
}",
  "languages": [
    "javascript",
    "typescript",
  ],
  "level": "error",
  "metadata": {},
  "name": "prefer-loose-array-bounds-checks-in-loops",
  "negativeExamples": [],
  "positiveExamples": [],
  "scope": "file",
  "source": "fixtures/valid-rules/prefer-loose-array-bounds-checks-in-loops.md",
  "tags": [
    "best practices",
  ],
  "title": "Prefer loose array bounds checks in loops",
}
`;

exports[`parseRuleFile - fixtures/valid-rules/prefer-page-queries.md 1`] = `
{
  "cacheable": true,
  "description": "Warn on usage of the \`/utils/api.ts\` file in favor of creating a page query in the /\`utils/pageQueries\` folder.

## Usage Examples
",
  "level": "error",
  "metadata": {},
  "name": "prefer-page-queries",
  "negativeExamples": [
    {
      "code": "export const get<queryName>Data = async (
  locale: string
): Promise<<queryName>Type | null> => {
  try {
    const data = await fetchCmsGraphql(GET_<queryName>, {
      locale,
    });
    return data?.<queryName>?.data?.attributes || null;
  } catch (error) {
    console.error(error);
    return null;
  }
};",
      "language": "ts",
    },
  ],
  "positiveExamples": [
    {
      "code": "import { print } from 'graphql';
import {
  <queryName>Query,
  <queryName>QueryVariables,
} from './AboutUsPage.generated';
export type { <queryName>Query, <queryName>QueryVariables };
import QUERY from './AboutUsPage';
import { fetchCmsGraphql } from '../../fetchCmsData';

export const get<queryName>PageData = async (
  variables: <queryName>PageQueryVariables
): Promise<<queryName>Query | null> => {
  try {
    const data = await fetchCmsGraphql(print(QUERY), variables);
    return data as <queryName>Query;
  } catch (error) {
    console.error(error);
    return null;
  }
};",
      "language": "ts",
    },
    {
      "code": "import gql from 'graphql-tag'

export default gql\`
  query <queryName> {
    # query here
  }
\`",
      "language": "tsx",
    },
  ],
  "scope": "file",
  "source": "fixtures/valid-rules/prefer-page-queries.md",
  "title": "Prefer page queries",
}
`;

exports[`parseRuleFile - fixtures/valid-rules/prefer-strapi-env-vars.md 1`] = `
{
  "cacheable": true,
  "description": "Avoid accessing \`process.env\` variables in favor of Strapi environment variables.

## Usage Examples
",
  "level": "error",
  "metadata": {},
  "name": "prefer-strapi-env-vars",
  "negativeExamples": [
    {
      "code": "export default ({ env }) => ({
  auth: {
    secret: process.env['ADMIN_JWT_SECRET']
  }
})",
      "language": "ts",
    },
    {
      "code": "export default ({ env }) => ({
  auth: {
    secret: process.env.ADMIN_JWT_SECRET
  }
})",
      "language": "ts",
    },
  ],
  "positiveExamples": [
    {
      "code": "export default ({ env }) => ({
  auth: {
    secret: env('ADMIN_JWT_SECRET')
  }
})",
      "language": "ts",
    },
  ],
  "scope": "file",
  "source": "fixtures/valid-rules/prefer-strapi-env-vars.md",
  "title": "Use Strapi Environment Variables",
}
`;

exports[`parseRuleFile - fixtures/valid-rules/wip/format-comments-like-sentences.md 1`] = `
{
  "cacheable": true,
  "description": "Capitalize the first word unless it's a case-sensitive identifier. End it with a period (or "!" or "?", I suppose). This is true for all comments: doc comments, inline stuff, even TODOs. Even if it's a sentence fragment.
",
  "level": "error",
  "metadata": {},
  "name": "format-comments-like-sentences",
  "negativeExamples": [
    {
      "code": "// quick comment",
      "language": "ts",
    },
  ],
  "positiveExamples": [
    {
      "code": "// Quick comment.",
      "language": "ts",
    },
  ],
  "scope": "file",
  "source": "fixtures/valid-rules/wip/format-comments-like-sentences.md",
  "title": "Format comments like sentences",
}
`;

exports[`parseRuleFile - fixtures/valid-rules/wip/prefer-defensive-programming.md 1`] = `
{
  "cacheable": true,
  "description": "Defensive programming is a mindset and series of techniques aimed at improving software quality and reliability by writing code that expects the unexpected and gracefully handles these unexpected inputs at runtime. Defensive programming is proactive in failing fast, handling errors, validating inputs, and maintaining consistent state under unexpected conditions, ensuring that the program behaves correctly even in unforeseen scenarios.

The following defensive programming techniques should be preferred whenever possible:

- [Validate external data with type guards or schema validation](#validate-external-data-with-type-guards-or-schema-validation)
- [Use optional chaining and nullish coalescing where appropriate](#use-optional-chaining-and-nullish-coalescing-where-appropriate)
- [Prefer loose array bounds checks over more brittle exact checks](#prefer-loose-array-bounds-checks-over-more-brittle-exact-checks)
- [Prefer readonly and Partial utility types](#prefer-readonly-and-partial-utility-types)
- [Ensure exhaustiveness in switch statements](#ensure-exhaustiveness-in-switch-statements)
- [Use defensive error handling](#use-defensive-error-handling)

## Validate external data with type guards or schema validation

When dealing with data from external sources (like public APIs), don't just trust that the payload matches your internal types. If you're dealing with external data which you can't trust, then prefer using a validation library like \`zod\` with type guards to validate the shape and type of the external data at runtime.

\`\`\`ts
import { z } from 'zod'

const UserProfileSchema = z.object({
  id: z.number(),
  name: z.string(),
  email: z.string().optional()
})

// Example of an external data source (e.g., API response)
const externalData = {
  id: 1,
  name: 'Jane Doe',
  email: 'jane.doe@example.com'
}

try {
  // Validate the external data against the schema
  const userProfile = UserProfileSchema.parse(externalData)
  console.log('Validated User Profile:', userProfile)
} catch (error) {
  console.error('Validation Failed:', error.errors)
}
\`\`\`

NOTE: **You do not always need to validate function arguments**. This suggestion is only meant for when you are sure you're dealing with **external data that your program does not trust**. For normal function arguments, you can safely ignore this rule.

## Use optional chaining and nullish coalescing where appropriate

Code written with a defensive mindset will often contain a lot of optional chaining (\`?.\`) and nullish coalescing (\`??\`).

\`\`\`ts
function getFirstName(user?: User, defaultName = 'john'): string {
  return user?.name?.split(' ')[0] ?? defaultName
}
\`\`\`

You can accomplish the same logic without these newer ECMAScript features, but the code will be a lot more verbose and error-prone.

## Prefer loose array bounds checks over more brittle exact checks

Array bounds checks within loops should verify if a variable is \`>=\` or \`<=\` the array length instead of exactly equal to the array length. Performing strict bound checks on arrays in loops is brittle and a common cause of subtle bugs.

\`\`\`js
function handleTasks() {
  const tasks = [
    // ...
  ]
  let currentTaskIndex = 0

  do {
    const currentTask = tasks[currentTaskIndex]

    // process task
    // ...

    currentTaskIndex++
  } while (currentTaskIndex !== tasks.length)
}
\`\`\`

This example has two bugs:

- if \`tasks\` is empty, the first iteration of the while loop will throw an error
- the \`while\` loop guard is very brittle which is a code smell. if \`currentTaskIndex\` somehow gets changed in an unexpected way with future code changes, then the \`while\` loop guard could end up going past the end of the tasks array!

An improved version of this code which fixes these buse looks like:

\`\`\`js
function handleTasks() {
  const tasks = [
    // ...
  ]
  let currentTaskIndex = 0

  while (currentTaskIndex < tasks.length) {
    const currentTask = tasks[currentTaskIndex]

    // process task
    // ...

    currentTaskIndex++
  }
}
\`\`\`

## Prefer readonly and Partial utility types

\`Readonly\` and \`Partial\` are great defensive types that should be used where possible to prevent unintended mutations, but we don't require their use in this codebase.

\`\`\`ts
function createUser(user: Readonly<Partial<User>>) {
  // Now 'user' is a readonly object, preventing accidental mutations
  return {
    ...user,
    id: '...'
  }
}

createUser({ name: 'Alex' })
\`\`\`

## Ensure exhaustiveness in switch statements

\`\`\`ts
type Action = 'create' | 'update' | 'delete'

function performAction(action: Action) {
  switch (action) {
    case 'create':
      // Handle create
      break

    case 'update':
      // Handle update
      break

    case 'delete':
      // Handle delete
      break

    default:
      throw new Error(\`Unexpected action "\${action}"\`)
  }
}
\`\`\`

## Use defensive error handling

Prefer wrapping potentially error-prone operations (e.g., network requests, file I/O) in \`try-catch\` blocks to handle and gracefully recover from unexpected runtime errors.
",
  "exclude": [
    "**/*.test\\.{js,ts,jsx,tsx,cjs,mjs}",
  ],
  "fixable": false,
  "languages": [
    "javascript",
    "typescript",
  ],
  "level": "error",
  "metadata": {},
  "name": "prefer-defensive-programming",
  "negativeExamples": [],
  "positiveExamples": [],
  "scope": "file",
  "source": "fixtures/valid-rules/wip/prefer-defensive-programming.md",
  "tags": [
    "best practices",
  ],
  "title": "Prefer defensive programming techniques <!-- omit from toc -->",
}
`;

exports[`parseRuleFile - fixtures/valid-rules/wip/prefer-early-return.md 1`] = `
{
  "cacheable": true,
  "description": "Prefer returning early from functions in order to keep them as flat as possible.

Ignore \`if\` statements with multiple \`else\` branches.

Ignore \`if\` statements which include a \`return\` or \`throw\` in their body.

\`if\` statements containing only a single statement in their body are okay and should be ignored by this rule.
",
  "eslint": [
    "prefer-early-return",
  ],
  "exclude": [
    "**/*.test\\.{js,ts,jsx,tsx,cjs,mjs}",
  ],
  "fixable": false,
  "gritql": "function_declaration",
  "languages": [
    "javascript",
    "typescript",
  ],
  "level": "error",
  "metadata": {},
  "name": "prefer-early-return",
  "negativeExamples": [
    {
      "code": "function handleClick(event) {
  if (event.target.matches('.save-data')) {
    let id = event.target.getAttribute('data-id')

    if (id) {
      let token = localStorage.getItem('token')

      if (token) {
        localStorage.setItem(\`\${token}_\${id}\`, true)
      }
    }
  }
}",
      "language": "js",
    },
  ],
  "positiveExamples": [
    {
      "code": "function handleClick(event) {
  if (!event.target.matches('.save-data')) return

  let id = event.target.getAttribute('data-id')
  if (!id) return

  let token = localStorage.getItem('token')
  if (!token) return

  localStorage.setItem(\`\${token}_\${id}\`, true)
}",
      "language": "js",
    },
    {
      "code": "function example() {
  const res = await fetch()
  if (!res) {
    return
  }

  // process res
}",
      "language": "ts",
    },
    {
      "code": "function example() {
  const res = await fetch()
  if (!res) return

  // process res
}",
      "language": "ts",
    },
    {
      "code": "function foo() {
  if (a) {
    b()
  }
}",
      "language": "js",
    },
  ],
  "resources": [
    "https://gomakethings.com/the-early-return-pattern-in-javascript/",
  ],
  "scope": "file",
  "source": "fixtures/valid-rules/wip/prefer-early-return.md",
  "tags": [
    "best practices",
  ],
  "title": "Prefer early returns from functions",
}
`;

exports[`parseRuleFile - fixtures/valid-rules/wip/react-prefer-derived-state.md 1`] = `
{
  "cacheable": true,
  "description": "State which is simple to derive should be re-derived when necessary instead of storing it in state or props.

TODO
",
  "level": "error",
  "metadata": {},
  "name": "react-prefer-derived-state",
  "negativeExamples": [],
  "positiveExamples": [],
  "scope": "file",
  "source": "fixtures/valid-rules/wip/react-prefer-derived-state.md",
  "title": "Prefer derived state in React",
}
`;

exports[`parseRuleFile - fixtures/valid-rules/wip/use-esm.md 1`] = `
{
  "cacheable": true,
  "description": "CommonJS code is deprecated and should be avoided going forwards. CommonJS code uses \`require\` and \`module.exports\` and suffers from poor standardization and interoperability issues.

ESM (ECMAScript Modules) is a modern standard which uses \`import\` and \`export\` statements. It is preferred for all JS/TS code going forwards.
",
  "eslint": [
    "@unicorn/prefer-module",
    "@typescript-eslint/no-require-imports",
  ],
  "level": "error",
  "metadata": {},
  "name": "use-esm",
  "negativeExamples": [
    {
      "code": "const path = require('path')

module.exports = function foo() {}",
      "language": "js",
    },
  ],
  "positiveExamples": [
    {
      "code": "import path from 'path'

export default function foo() {}
export function bar() {}",
      "language": "js",
    },
  ],
  "scope": "file",
  "source": "fixtures/valid-rules/wip/use-esm.md",
  "title": "Use ESM instead of CommonJS",
}
`;
